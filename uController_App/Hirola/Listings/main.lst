C51 COMPILER V9.59.0.0   MAIN                                                              01/13/2019 16:59:33 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2           * @author Krzysztof Stezala
   3           * @date 2019-01-12
   4           * @version 1.0
   5           * @brief UART communication with third-party app
   6           */
   7           
   8           
   9           
  10          #include "aduc831.h"
  11          #include "timers.h"
  12          #include "definitions.h"
  13          
  14          char buffer[25];
  15          char uart_buffer[25];
  16          int local_index;
  17          
  18          char message_index;
  19          
  20          int frequency_1;                                                  // ch#1 freq value
  21          char frequency_1_t[8];                                            // char array to analyze
  22          int duty_cycle_1;                                                 // after processing
  23          char duty_cycle_1_t[2];                                           // before processing
  24          
  25          int frequency_2;                                                  // ch#2 freq value
  26          char frequency_2_t[8];                                            // char array to convert
  27          int duty_cycle_2;                                                 // ch#2 duty cycle value
  28          char duty_cycle_2_t[2];                                           //
  29            
  30          int operation_mode;
  31          
  32          char ascii_offset;
  33          int conversion_scaler;
  34          int i;
  35          
  36          bool new_data = FALSE;
  37          bool mode_data = FALSE;
  38          bool duty_cycle_data = FALSE;
  39          bool freq_data = FALSE;
  40          bool two_channel = FALSE;
  41          bool is_read = TRUE;
  42          
  43          void receiveMessage() interrupt 4
  44          {
  45   1        /**
  46   1        * Receiving transmission
  47   1        */
  48   1        char received = 0;
  49   1        if(RI==1){
  50   2          received = (char)SBUF;
  51   2          RI = 0;
  52   2          //SBUF = received;
  53   2          buffer[message_index] = received;
  54   2          message_index = message_index + 1;
C51 COMPILER V9.59.0.0   MAIN                                                              01/13/2019 16:59:33 PAGE 2   

  55   2        }
  56   1        if(TI==1){
  57   2          TI = 0;
  58   2        }
  59   1        
  60   1        if(received == 'E')
  61   1        {
  62   2          is_read = FALSE;
  63   2          message_index = 0;
  64   2          return;
  65   2        }
  66   1        else
  67   1        {
  68   2          is_read = TRUE;
  69   2        }
  70   1        /*
  71   1        if(message_index > 25)
  72   1        {
  73   1          message_index = 0;
  74   1        }*/
  75   1        
  76   1        return;
  77   1      }
  78          
  79          
  80          
  81          void analyzeData()
  82          {
  83   1        if(buffer[local_index]=='S')
  84   1            {
  85   2              new_data = TRUE;
  86   2          
  87   2              mode_data = TRUE;
  88   2              freq_data = FALSE;
  89   2              duty_cycle_data = FALSE;
  90   2          
  91   2              local_index = local_index + 1;
  92   2              return;
  93   2            }
  94   1            else if(buffer[local_index] == 'D')
  95   1            {
  96   2              mode_data = FALSE;
  97   2              duty_cycle_data = TRUE;
  98   2              freq_data = FALSE;    
  99   2          
 100   2              local_index = local_index + 1;
 101   2              return;
 102   2            }
 103   1            else if(buffer[local_index] == 'F')
 104   1            {
 105   2              mode_data = FALSE;
 106   2              duty_cycle_data = FALSE;
 107   2              freq_data = TRUE;
 108   2              
 109   2              local_index = local_index + 1;
 110   2              return;
 111   2            }
 112   1        
 113   1            /**
 114   1            * Incoming data analysis
 115   1            */
 116   1            if(new_data)
C51 COMPILER V9.59.0.0   MAIN                                                              01/13/2019 16:59:33 PAGE 3   

 117   1            {
 118   2              if(mode_data)
 119   2              {
 120   3                operation_mode = buffer[local_index];
 121   3                if(operation_mode == 49)
 122   3                {
 123   4                  two_channel = FALSE;
 124   4                }
 125   3                else
 126   3                {
 127   4                  two_channel = TRUE;
 128   4                }
 129   3              }
 130   2            }
 131   1          
 132   1            if(duty_cycle_data)
 133   1            {
 134   2              if(!two_channel)
 135   2              {
 136   3                // for single channel
 137   3                duty_cycle_1_t[local_index - 3] = buffer[local_index];
 138   3              } 
 139   2              else
 140   2              {
 141   3                // for double channel
 142   3                if(local_index < 5)
 143   3                {
 144   4                  duty_cycle_1_t[local_index - 3] = buffer[local_index];
 145   4                }
 146   3                else
 147   3                {
 148   4                  duty_cycle_2_t[local_index - 5] = buffer[local_index];
 149   4                }
 150   3              }
 151   2            }
 152   1          
 153   1            if(freq_data)
 154   1            { 
 155   2              if(!two_channel)                                            // for single channel
 156   2              {
 157   3                frequency_1_t[local_index - 6] = buffer[local_index];
 158   3              }
 159   2              else                                                        // for two channels
 160   2              {
 161   3                if(local_index < 16)
 162   3                {
 163   4                  frequency_1_t[local_index - 8] = buffer[local_index];
 164   4                }
 165   3                else
 166   3                {
 167   4                  frequency_2_t[local_index - 16] = buffer[local_index];
 168   4                }
 169   3              }
 170   2            }
 171   1            //SBUF = buffer[local_index];
 172   1            local_index = local_index + 1;
 173   1            return;
 174   1      }
 175          
 176          
 177          void getValues()                                                    // convert duty cycles and freqs to ints
 178          { 
C51 COMPILER V9.59.0.0   MAIN                                                              01/13/2019 16:59:33 PAGE 4   

 179   1        if(!two_channel)
 180   1        {
 181   2          conversion_scaler = 1;                                          // scaler for retrieving values
 182   2          
 183   2          frequency_1 = 0;                                                // resetting frequency 1
 184   2              
 185   2          for(i=7;i>=0;i--)                                               // calculating frequency 1
 186   2          {     
 187   3            frequency_1 = (frequency_1_t[i] - ascii_offset) * conversion_scaler + frequency_1;      
 188   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 189   3          }
 190   2          
 191   2          conversion_scaler = 1;                                          // scaler for retrieving values
 192   2          
 193   2          duty_cycle_1 = 0;                                               // resetting duty cycle 1
 194   2          
 195   2          for(i=1;i>=0;i--)                                               // calculating duty cycle 1
 196   2          {
 197   3            duty_cycle_1 = (duty_cycle_1_t[i] - ascii_offset) * conversion_scaler + duty_cycle_1;
 198   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 199   3          }
 200   2        }
 201   1        else
 202   1        {
 203   2          conversion_scaler = 1;                                          // scaler for retrieving values   
 204   2          
 205   2          frequency_1 = 0;                                                // resetting frequency 1
 206   2          
 207   2          for(i=7;i>=0;i--)                                               // calculating frequency 1
 208   2          {
 209   3            frequency_1 = (frequency_1_t[i] - ascii_offset) * conversion_scaler + frequency_1;  
 210   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 211   3          }
 212   2          
 213   2          conversion_scaler = 1;                                          // scaler for retrieving values   
 214   2          
 215   2          duty_cycle_1 = 0;                                               // resetting duty cycle 1
 216   2              
 217   2          for(i=1;i>=0;i--)                                               // calculating duty cycle 1
 218   2          {
 219   3            duty_cycle_1 = (duty_cycle_1_t[i] - ascii_offset) * conversion_scaler + duty_cycle_1;
 220   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 221   3          }
 222   2          
 223   2          conversion_scaler = 1;                                          // scaler for retrieving values   
 224   2          
 225   2          frequency_2 = 0;                                                // resetting frequency 2
 226   2          
 227   2          for(i=7;i>=0;i--)                                               // calculating frequency 2
 228   2          {
 229   3            frequency_2 = (frequency_2_t[i] - ascii_offset) * conversion_scaler + frequency_2;  
 230   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 231   3          }
 232   2          
 233   2          conversion_scaler = 1;                                          // scaler for retrieving values
 234   2          
 235   2          duty_cycle_2 = 0;                                               // resetting duty cycle 2
 236   2          
 237   2          for(i=1;i>=0;i--)                                               // calculating duty cycle 2
 238   2          {
 239   3            duty_cycle_2 = (duty_cycle_2_t[i] - ascii_offset) * conversion_scaler + duty_cycle_2;
 240   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
C51 COMPILER V9.59.0.0   MAIN                                                              01/13/2019 16:59:33 PAGE 5   

 241   3          }
 242   2        }
 243   1      }
 244          
 245          /**
 246           * main function
 247           */
 248          void main()
 249          {
 250   1        /**
 251   1        * Enable the interrupts - general and UART
 252   1        */
 253   1        ES = 1;
 254   1        EA = 1;
 255   1        
 256   1        
 257   1        /**
 258   1        * UART set into Mode 1 (8-bit, Variable Baud Rate)
 259   1        */
 260   1        SM0 = 0;
 261   1        SM1 = 1;
 262   1        SM2 = 0;
 263   1        REN = 1;
 264   1        
 265   1        /**
 266   1        * Timer 1 set into 8-bit, autoreload mode, 9600bps at 11,0952 MHz
 267   1        */
 268   1        TMOD = T1_MODE_8B_AUTORELOAD;
 269   1        TH1 = T1_9600_11; 
 270   1        TR1 = 1;
 271   1        
 272   1        /**
 273   1        * Initial set up
 274   1        */
 275   1        message_index = 0;
 276   1        local_index = 0;
 277   1        ascii_offset = 48;
 278   1        
 279   1        
 280   1        while(1)
 281   1        {
 282   2          
 283   2          while(buffer[local_index]!='E' && !is_read)
 284   2          {
 285   3            analyzeData();
 286   3          }
 287   2          if(buffer[local_index]=='E')
 288   2          {
 289   3            is_read = TRUE;
 290   3            getValues();
 291   3            local_index = 0;
 292   3          }
 293   2          
 294   2          
 295   2          
 296   2        }
 297   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    899    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.59.0.0   MAIN                                                              01/13/2019 16:59:33 PAGE 6   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     94    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
