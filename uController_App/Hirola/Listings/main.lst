C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2019 14:15:00 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2           * @author Krzysztof Stezala
   3           * @date 2019-01-12
   4           * @version 1.0
   5           * @brief UART communication with third-party app
   6           */
   7           
   8           
   9           
  10          #include "aduc831.h"
  11          #include "timers.h"
  12          #include "definitions.h"
  13          #include "putchar.h"
  14          
  15          char buffer[25];
  16          char uart_buffer[25];
  17          int local_index;
  18          
  19          char return_message[5] = {'h','e', 'l', 'l', 'o'};
  20          
  21          char message_index;
  22          
  23          int frequency_1;                                                  // ch#1 freq value
  24          char frequency_1_t[8];                                            // char array to analyze
  25          int duty_cycle_1;                                                 // after processing
  26          char duty_cycle_1_t[2];                                           // before processing
  27          
  28          int frequency_2;                                                  // ch#2 freq value
  29          char frequency_2_t[8];                                            // char array to convert
  30          int duty_cycle_2;                                                 // ch#2 duty cycle value
  31          char duty_cycle_2_t[2];                                           //
  32            
  33          int operation_mode;
  34          
  35          char ascii_offset;
  36          int conversion_scaler;
  37          int i;
  38          int j;
  39          
  40          bool new_data = FALSE;
  41          bool mode_data = FALSE;
  42          bool duty_cycle_data = FALSE;
  43          bool freq_data = FALSE;
  44          bool two_channel = FALSE;
  45          bool is_read = TRUE;
  46          
  47          bool do_it_once = TRUE;
  48          
  49          void showResults(){
  50   1        PWMCON=0x00;
  51   1        setBit(PWMCON,4);
  52   1        setBit(PWMCON,1);
  53   1        setBit(PWMCON,0);
  54   1        
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2019 14:15:00 PAGE 2   

  55   1        PWM1H=0xFF;
  56   1        PWM1L=0xFF;
  57   1        PWM0H=0x44;
  58   1        PWM0L=0xFF;
  59   1      }
  60          void sendMessage()
  61          {
  62   1        j = 0;
  63   1        for(j = 0;j<5;j++){
  64   2          putchar(return_message[j]);
  65   2        }
  66   1        putchar('\n');
  67   1      }
  68          
  69          void receiveMessage() interrupt 4
  70          {
  71   1        /**
  72   1        * Receiving transmission
  73   1        */
  74   1        char received = 0;
  75   1        if(RI==1){
  76   2          received = (char)SBUF;
  77   2          RI = 0;
  78   2          
  79   2          //SBUF = received;
  80   2          buffer[message_index] = received;
  81   2          if((message_index == 1) && (received == 'G'))
  82   2          {
  83   3            // it's request for data
  84   3            // dont follow further
  85   3            // execute function for sending data
  86   3            
  87   3            sendMessage();
  88   3            message_index = 0;
  89   3            return;
  90   3          }
  91   2          message_index = message_index + 1;
  92   2          
  93   2        }
  94   1        if(TI==1){
  95   2          TI = 0;
  96   2        }
  97   1        
  98   1        if(received == 'E')
  99   1        {
 100   2          is_read = FALSE;
 101   2          message_index = 0;
 102   2          return;
 103   2        }
 104   1        else
 105   1        {
 106   2          is_read = TRUE;
 107   2        }
 108   1        /*
 109   1        if(message_index > 25)
 110   1        {
 111   1          message_index = 0;
 112   1        }*/
 113   1        
 114   1        return;
 115   1      }
 116          
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2019 14:15:00 PAGE 3   

 117          
 118          
 119          void analyzeData()
 120          {
 121   1        if(buffer[local_index]=='S')
 122   1            {
 123   2              new_data = TRUE;
 124   2          
 125   2              mode_data = TRUE;
 126   2              freq_data = FALSE;
 127   2              duty_cycle_data = FALSE;
 128   2          
 129   2              local_index = local_index + 1;
 130   2              return;
 131   2            }
 132   1            else if(buffer[local_index] == 'D')
 133   1            {
 134   2              mode_data = FALSE;
 135   2              duty_cycle_data = TRUE;
 136   2              freq_data = FALSE;    
 137   2          
 138   2              local_index = local_index + 1;
 139   2              return;
 140   2            }
 141   1            else if(buffer[local_index] == 'F')
 142   1            {
 143   2              mode_data = FALSE;
 144   2              duty_cycle_data = FALSE;
 145   2              freq_data = TRUE;
 146   2              
 147   2              local_index = local_index + 1;
 148   2              return;
 149   2            }
 150   1        
 151   1            /**
 152   1            * Incoming data analysis
 153   1            */
 154   1            if(new_data)
 155   1            {
 156   2              if(mode_data)
 157   2              {
 158   3                operation_mode = buffer[local_index];
 159   3                if(operation_mode == 49)
 160   3                {
 161   4                  two_channel = FALSE;
 162   4                }
 163   3                else
 164   3                {
 165   4                  two_channel = TRUE;
 166   4                }
 167   3              }
 168   2            }
 169   1          
 170   1            if(duty_cycle_data)
 171   1            {
 172   2              if(!two_channel)
 173   2              {
 174   3                // for single channel
 175   3                duty_cycle_1_t[local_index - 3] = buffer[local_index];
 176   3              } 
 177   2              else
 178   2              {
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2019 14:15:00 PAGE 4   

 179   3                // for double channel
 180   3                if(local_index < 5)
 181   3                {
 182   4                  duty_cycle_1_t[local_index - 3] = buffer[local_index];
 183   4                }
 184   3                else
 185   3                {
 186   4                  duty_cycle_2_t[local_index - 5] = buffer[local_index];
 187   4                }
 188   3              }
 189   2            }
 190   1          
 191   1            if(freq_data)
 192   1            { 
 193   2              if(!two_channel)                                            // for single channel
 194   2              {
 195   3                frequency_1_t[local_index - 6] = buffer[local_index];
 196   3              }
 197   2              else                                                        // for two channels
 198   2              {
 199   3                if(local_index < 16)
 200   3                {
 201   4                  frequency_1_t[local_index - 8] = buffer[local_index];
 202   4                }
 203   3                else
 204   3                {
 205   4                  frequency_2_t[local_index - 16] = buffer[local_index];
 206   4                }
 207   3              }
 208   2            }
 209   1            //SBUF = buffer[local_index];
 210   1            local_index = local_index + 1;
 211   1            return;
 212   1      }
 213          
 214          
 215          void getValues()                                                    // convert duty cycles and freqs to ints
 216          { 
 217   1        if(!two_channel)
 218   1        {
 219   2          conversion_scaler = 1;                                          // scaler for retrieving values
 220   2          
 221   2          frequency_1 = 0;                                                // resetting frequency 1
 222   2              
 223   2          for(i=7;i>=0;i--)                                               // calculating frequency 1
 224   2          {     
 225   3            frequency_1 = (frequency_1_t[i] - ascii_offset) * conversion_scaler + frequency_1;      
 226   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 227   3          }
 228   2          
 229   2          conversion_scaler = 1;                                          // scaler for retrieving values
 230   2          
 231   2          duty_cycle_1 = 0;                                               // resetting duty cycle 1
 232   2          
 233   2          for(i=1;i>=0;i--)                                               // calculating duty cycle 1
 234   2          {
 235   3            duty_cycle_1 = (duty_cycle_1_t[i] - ascii_offset) * conversion_scaler + duty_cycle_1;
 236   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 237   3          }
 238   2        }
 239   1        else
 240   1        {
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2019 14:15:00 PAGE 5   

 241   2          conversion_scaler = 1;                                          // scaler for retrieving values   
 242   2          
 243   2          frequency_1 = 0;                                                // resetting frequency 1
 244   2          
 245   2          for(i=7;i>=0;i--)                                               // calculating frequency 1
 246   2          {
 247   3            frequency_1 = (frequency_1_t[i] - ascii_offset) * conversion_scaler + frequency_1;  
 248   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 249   3          }
 250   2          
 251   2          conversion_scaler = 1;                                          // scaler for retrieving values   
 252   2          
 253   2          duty_cycle_1 = 0;                                               // resetting duty cycle 1
 254   2              
 255   2          for(i=1;i>=0;i--)                                               // calculating duty cycle 1
 256   2          {
 257   3            duty_cycle_1 = (duty_cycle_1_t[i] - ascii_offset) * conversion_scaler + duty_cycle_1;
 258   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 259   3          }
 260   2          
 261   2          conversion_scaler = 1;                                          // scaler for retrieving values   
 262   2          
 263   2          frequency_2 = 0;                                                // resetting frequency 2
 264   2          
 265   2          for(i=7;i>=0;i--)                                               // calculating frequency 2
 266   2          {
 267   3            frequency_2 = (frequency_2_t[i] - ascii_offset) * conversion_scaler + frequency_2;  
 268   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 269   3          }
 270   2          
 271   2          conversion_scaler = 1;                                          // scaler for retrieving values
 272   2          
 273   2          duty_cycle_2 = 0;                                               // resetting duty cycle 2
 274   2          
 275   2          for(i=1;i>=0;i--)                                               // calculating duty cycle 2
 276   2          {
 277   3            duty_cycle_2 = (duty_cycle_2_t[i] - ascii_offset) * conversion_scaler + duty_cycle_2;
 278   3            conversion_scaler = conversion_scaler * 10;                   // incrementing order of magnitude
 279   3          }
 280   2        }
 281   1      }
 282          
 283          
 284          
 285          /**
 286           * main function
 287           */
 288          void main()
 289          {
 290   1        /**
 291   1        * Enable the interrupts - general and UART
 292   1        */
 293   1        ES = 1;
 294   1        EA = 1;
 295   1        
 296   1        
 297   1        /**
 298   1        * UART set into Mode 1 (8-bit, Variable Baud Rate)
 299   1        */
 300   1        SM0 = 0;
 301   1        SM1 = 1;
 302   1        SM2 = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              01/17/2019 14:15:00 PAGE 6   

 303   1        REN = 1;
 304   1        
 305   1        /**
 306   1        * Timer 1 set into 8-bit, autoreload mode, 9600bps at 11,0952 MHz
 307   1        */
 308   1        TMOD = T1_MODE_8B_AUTORELOAD;
 309   1        TH1 = T1_9600_11; 
 310   1        TR1 = 1;
 311   1        
 312   1        /**
 313   1        * Initial set up
 314   1        */
 315   1        message_index = 0;
 316   1        local_index = 0;
 317   1        ascii_offset = 48;
 318   1        
 319   1        
 320   1        while(1)
 321   1        {
 322   2          
 323   2          while(buffer[local_index]!='E' && !is_read)
 324   2          {
 325   3            analyzeData();
 326   3          }
 327   2          if(buffer[local_index]=='E')
 328   2          {
 329   3            is_read = TRUE;
 330   3            getValues();
 331   3            local_index = 0;
 332   3          }
 333   2          // update status of the board while not reading
 334   2          
 335   2        
 336   2          
 337   2        }
 338   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1031    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =    102       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
